# This file is part of Jlsca, license is GPLv3, see https://www.gnu.org/licenses/gpl-3.0.en.html
#
# Author: Cees-Bart Breunesse

export bit0,bit1,bit2,bit3,bit4,bit5,bit6,bit7
export hw
export id

export basisModelSingleBits

# some leakages for CPA

bit(x,i) = (x .>> i) & 1
bit0(x) = bit(x,0)
bit1(x) = bit(x,1)
bit2(x) = bit(x,2)
bit3(x) = bit(x,3)
bit4(x) = bit(x,4)
bit5(x) = bit(x,5)
bit6(x) = bit(x,6)
bit7(x) = bit(x,7)

# hw(x) = map(y -> hamming(y,convert(UInt8, 0)), x)

const hw_table = [0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x02,0x03,0x03,0x04,0x03,0x04,0x04,0x05,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x06,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x04,0x05,0x05,0x06,0x05,0x06,0x06,0x07,0x05,0x06,0x06,0x07,0x06,0x07,0x07,0x08]

function hw(x::UInt8)
  return hw_table[x + 1]
end

# function hw(x::UInt8)
#     ret::UInt8 = 0
#     for i in 0:7
#       if (x >> i) & 1 == 1
#         ret += 1
#       end
#     end
#     return ret
# end

function hw(x::UInt32)
    ret::UInt8 = 0
    for i in 0:3
      ret += hw(UInt8((x >> (i*8)) & 0xff))
    end
    return ret
end

function hw(x::Array)
  return map(hw,x)
end

# function hw32(x::Vector{UInt8})
#   return map(hw,reinterpret(UInt32, x))
# end

function hw32(x::Matrix{UInt8})
  return vec(map(hw,reinterpret(UInt32, x, (1,4))))
end

id(x) = x



# some models for LRA

function basisModelSingleBits(x::UInt8, bitWidth=8)
  g = zeros(Float64, bitWidth+1)
  for i in 1:bitWidth
      g[i] = (x >> (i-1)) & 1
  end
  g[length(g)] = 1

  return g
end

# TODO: understand why bitWidth=32 results in non-invertable matrices.
function basisModelSingleBits(x::Integer, bitWidth=8)
  g = zeros(Float64, bitWidth+1)
  for i in 1:bitWidth
      g[i] = (x >> (i-1)) & 1
  end
  g[length(g)] = 1

  return g
end

# function basisModelSingleBits(x::UInt32, bits=collect(1:31))
#   g = zeros(Float64, length(bits)+1)
#   for i in bits
#       g[i] = (x >> (i-1)) & 1
#   end
#   g[length(g)] = 1

#   return g
# end
